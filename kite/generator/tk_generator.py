from typing import List, Tuple, Dict, Any
import os
import json
from datetime import datetime
from ..model import UiNode
from ..mapping.winforms_map import WINFORMS_TO_TK, PROP_MAP
from ..mapping.wpf_map import WPF_TO_TK
from ..utils.fs import write_text
from ..utils.naming import safe_name
from ..utils.colors import color_to_hex


class TkGenerator:
    def _widget_ctor(self, node: UiNode, for_kind: str) -> Tuple[str, str]:
        if for_kind == "winforms":
            mod, cls = WINFORMS_TO_TK.get(node.type, ("widgets", "Placeholder"))
        else:
            mod, cls = WPF_TO_TK.get(node.type, ("widgets", "Placeholder"))
        return mod, cls

    def _to_kwargs(self, node: UiNode, mod: str, cls: str) -> List[str]:
        skip = {"Dock", "Location", "Size", "Height", "Width", "FlatStyle", "Cursor", "BorderStyle", "FlatAppearance", "Font", "Padding"}
        kwargs = []
        for k, v in node.properties.items():
            if k in skip:
                continue
            if cls == 'Text' and mod == 'tk' and k == 'Text':
                continue
            tk_k = PROP_MAP.get(k, k.lower())
            # Drop color/font kwargs for ttk widgets (use default theme)
            if mod == 'ttk' and tk_k in ("background", "foreground", "font"):
                continue
            if isinstance(v, str):
                if k in ("ForeColor", "BackColor", "Background", "Foreground"):
                    v = color_to_hex(v)
                    kwargs.append(f"{tk_k}='{v}'")
                else:
                    esc = v.replace("'", "\\'")
                    kwargs.append(f"{tk_k}='{esc}'")
            elif isinstance(v, bool):
                kwargs.append(f"{tk_k}={'normal' if v else 'disabled'}" if tk_k == 'state' else f"{tk_k}={v}")
            elif isinstance(v, int):
                kwargs.append(f"{tk_k}={v}")
        return kwargs

    def _place(self, node: UiNode) -> str:
        # Prepare padding for pack
        pad = node.properties.get("Padding")
        pad_args = []
        if isinstance(pad, int):
            pad_args.append(f"padx={pad}")
            pad_args.append(f"pady={pad}")
        elif isinstance(pad, tuple) and len(pad) == 4:
            l, t, r, b = pad
            pad_args.append(f"padx=({l}, {r})")
            pad_args.append(f"pady=({t}, {b})")
        pad_str = (', ' + ', '.join(pad_args)) if pad_args else ''

        # Dock beats absolute placement
        dock = node.properties.get("Dock")
        if isinstance(dock, str):
            m = dock.lower()
            if m == 'fill':
                return f".pack(fill='both', expand=True{pad_str})"
            side = {'top':'top','bottom':'bottom','left':'left','right':'right'}.get(m)
            if side:
                fill = 'x' if side in ('top','bottom') else 'y'
                return f".pack(side='{side}', fill='{fill}'{pad_str})"
        loc = node.properties.get("Location") or node.properties.get("Margin")
        size = node.properties.get("Size") or node.properties.get("Width")
        parts = []
        if isinstance(loc, dict):
            parts.append(f"x={loc.get('x',0)}")
            parts.append(f"y={loc.get('y',0)}")
        if isinstance(size, dict):
            parts.append(f"width={size.get('w')}")
            parts.append(f"height={size.get('h')}")
        return f".place({', '.join(parts)})" if parts else f".pack(anchor='nw'{pad_str})"

    def generate_window(self, app_pkg_dir: str, node: UiNode) -> Tuple[str, List[Dict[str, Any]], List[Dict[str, Any]]]:
        fname = f"window_{safe_name(node.name)}.py"
        path = os.path.join(app_pkg_dir, fname)
        imports = ["# Generated by Kite", "import tkinter as tk", "from tkinter import ttk", "from . import custom as widgets"]
        lines: List[str] = []
        lines.extend(imports)
        lines.append("")
        positions: List[Dict[str, Any]] = []
        colors: List[Dict[str, Any]] = []
        class_name = safe_name(node.name).title().replace('_', '')
        base = "tk.Tk" if node.type in ("Form", "Window") else "tk.Toplevel"
        lines.append(f"class {class_name}({base}):")
        lines.append(f"    def __init__(self, *args, **kwargs):")
        lines.append(f"        super().__init__(*args, **kwargs)")
        title = node.properties.get("Text") or node.properties.get("Title") or node.name
        size = node.properties.get("ClientSize")
        if isinstance(size, dict):
            lines.append(f"        self.geometry('{size.get('w',400)}x{size.get('h',300)}')")
        lines.append(f"        self.title('{title}')")
        # Emit children
        emitted = 0
        for child in node.children:
            self._emit_widget(lines, parent_var='self', child=child, level=2, for_kind='winforms' if node.type == 'Form' else 'wpf', parent_type=None, positions=positions, colors=colors)
            emitted += 1
        if emitted == 0:
            # Create richer placeholder UI so window isn't blank
            lines.append("        _menu = widgets.MenuBar(self)")
            lines.append("        self.config(menu=_menu.menu)")
            lines.append("        _toolbar = widgets.ToolBar(self)")
            lines.append("        _toolbar.pack(side='top', fill='x')")
            lines.append("        _main = ttk.Frame(self)")
            lines.append("        _main.pack(fill='both', expand=True)")
            lines.append("        _left = ttk.Frame(_main, width=180)")
            lines.append("        _left.pack(side='left', fill='y')")
            lines.append("        ttk.Label(_left, text='Navigation').pack(anchor='w', padx=6, pady=6)")
            lines.append("        ttk.Treeview(_left).pack(fill='both', expand=True, padx=6, pady=6)")
            lines.append("        _content = ttk.Notebook(_main)")
            lines.append("        _content.pack(side='left', fill='both', expand=True)")
            lines.append("        _tab = ttk.Frame(_content)")
            lines.append("        _content.add(_tab, text='Main')")
            lines.append("        ttk.Label(_tab, text='Kite placeholder: no controls parsed.').pack(anchor='w', padx=8, pady=8)")
            lines.append("        widgets.DataGrid(_tab, columns=('A','B','C')).pack(fill='both', expand=True, padx=8, pady=8)")
            lines.append("        _status = widgets.StatusBar(self, text='Ready')")
            lines.append("        _status.pack(side='bottom', fill='x')")
        write_text(path, "\n".join(lines))
        return fname, positions, colors

    def _emit_widget(self, lines: List[str], parent_var: str, child: UiNode, level: int, for_kind: str, parent_type: str | None = None, positions: List[Dict[str, Any]] | None = None, colors: List[Dict[str, Any]] | None = None):
        # Always emit at method indentation (no extra blocks), ignore 'level' to avoid unexpected indent
        indent = "    " * 2
        mod, cls = self._widget_ctor(child, for_kind)
        var = safe_name(child.name)
        kwargs = ", ".join(self._to_kwargs(child, mod, cls))
        # Special containers and menus
        if child.type == 'MenuStrip':
            lines.append(f"{indent}{var} = widgets.MenuBar({parent_var})")
            lines.append(f"{indent}{parent_var}.config(menu={var}.menu)")
            return
        if child.type == 'StatusStrip':
            lines.append(f"{indent}{var} = widgets.StatusBar({parent_var}, text='{child.properties.get('Text','Ready')}')")
            lines.append(f"{indent}{var}.pack(side='bottom', fill='x')")
            return
        if child.type == 'ToolStrip':
            lines.append(f"{indent}{var} = widgets.ToolBar({parent_var})")
            lines.append(f"{indent}{var}.pack(side='top', fill='x')")
            return

        # Create widget
        if mod == 'widgets':
            lines.append(f"{indent}{var} = widgets.{cls}({parent_var}{', ' if kwargs else ''}{kwargs})")
        else:
            lines.append(f"{indent}{var} = {mod}.{cls}({parent_var}{', ' if kwargs else ''}{kwargs})")

        # Collect EPAT data
        if positions is not None:
            loc = child.properties.get('Location')
            size = child.properties.get('Size')
            dock = child.properties.get('Dock')
            positions.append({
                'name': var,
                'type': child.type,
                'position': loc if isinstance(loc, dict) else None,
                'size': size if isinstance(size, dict) else None,
                'dock': dock if isinstance(dock, str) else None,
            })
        if colors is not None:
            bg = child.properties.get('BackColor') or child.properties.get('Background')
            fg = child.properties.get('ForeColor') or child.properties.get('Foreground')
            bg_hex = color_to_hex(bg) if isinstance(bg, str) else None
            fg_hex = color_to_hex(fg) if isinstance(fg, str) else None
            if bg_hex or fg_hex:
                colors.append({'name': var, 'type': child.type, 'background': bg_hex, 'foreground': fg_hex})

        # Notebook page handling
        if parent_type == 'Notebook':
            tab_text = child.properties.get('Text') or child.name
            lines.append(f"{indent}{parent_var}.add({var}, text='{tab_text}')")
        else:
            lines.append(f"{indent}{var}{self._place(child)}")

        for g in child.children:
            self._emit_widget(lines, var, g, level, for_kind, parent_type=cls)

    def generate_app(self, out_dir: str, generated: List[Tuple[str, str, List[Dict[str, Any]], List[Dict[str, Any]]]], main_window: str | None, kind: str | None = None) -> None:
        app_init = os.path.join(out_dir, 'app', '__init__.py')
        write_text(app_init, ("# Generated by Kite\nfrom . import custom\n"))
        # Custom widgets module
        custom_path = os.path.join(out_dir, 'app', 'custom.py')
        write_text(custom_path, "# Generated by Kite\n" + CUSTOM_CONTENT)
        # Main runner
        main_path = os.path.join(out_dir, 'main.py')
        imports = ["# Generated by Kite"]
        for name, fname, _pos, _col in generated:
            mod = os.path.splitext(fname)[0]
            class_name = safe_name(name).title().replace('_', '')
            imports.append(f"from app.{mod} import {class_name}")
        start = main_window or (generated[0][0] if generated else 'MainWindow')
        start_cls = safe_name(start).title().replace('_', '')
        code = imports + ["", f"def main():", f"    win = {start_cls}()", "    win.mainloop()", "", "if __name__ == '__main__':", "    main()"]
        write_text(main_path, "\n".join(code))

        # Write README
        readme = os.path.join(out_dir, 'README.md')
        readme_text = (
            "# Kite Output\n\n"
            "This directory was generated by Kite, a tool that converts .NET WinForms/WPF UIs into Python Tkinter code.\n\n"
            "- main.py: entry point to run the app\n\n"
            "- app/window_*.py: generated windows\n\n"
            "- app/custom.py: custom widgets that emulate .NET controls\n\n"
            "- .kite.xom: Kite configuration (not used at runtime)\n\n"
            "- serial.epat: element positions (for tooling)\n\n"
            "- pie.epat: color mapping per element (for tooling)\n\n"
        )
        write_text(readme, readme_text)

        # Write config .kite.xom
        cfg = {
            'generated_at': datetime.utcnow().isoformat() + 'Z',
            'project_kind': kind or 'unknown',
            'windows': [name for name, *_ in generated],
            'notes': 'This file is for Kite tooling only and does not affect app runtime.'
        }
        write_text(os.path.join(out_dir, '.kite.xom'), json.dumps(cfg, indent=2))

        # Write EPAT files
        serial: Dict[str, Any] = {}
        pie: Dict[str, Any] = {}
        for name, _fname, pos_list, col_list in generated:
            serial[name] = pos_list
            pie[name] = col_list
        write_text(os.path.join(out_dir, 'serial.epat'), json.dumps(serial, indent=2))
        write_text(os.path.join(out_dir, 'pie.epat'), json.dumps(pie, indent=2))


CUSTOM_CONTENT = """
import tkinter as tk
from tkinter import ttk

class HyperlinkLabel(ttk.Label):
    def __init__(self, master=None, text='', command=None, **kwargs):
        super().__init__(master, text=text, foreground='#0645AD', cursor='hand2', **kwargs)
        self._command = command
        self.bind('<Button-1>', lambda e: self._command() if self._command else None)
        self.bind('<Enter>', lambda e: self.configure(foreground='#0B0080'))
        self.bind('<Leave>', lambda e: self.configure(foreground='#0645AD'))

class PlaceholderEntry(ttk.Entry):
    def __init__(self, master=None, placeholder='', **kwargs):
        super().__init__(master, **kwargs)
        self.placeholder = placeholder
        self._has_placeholder = False
        self._show_placeholder()
        self.bind('<FocusIn>', self._clear_placeholder)
        self.bind('<FocusOut>', self._show_placeholder)

    def _show_placeholder(self, *args):
        if not self.get():
            self.insert(0, self.placeholder)
            self.configure(foreground='gray')
            self._has_placeholder = True

    def _clear_placeholder(self, *args):
        if self._has_placeholder:
            self.delete(0, 'end')
            self.configure(foreground='black')
            self._has_placeholder = False

class DataGrid(ttk.Treeview):
    def __init__(self, master=None, columns=None, **kwargs):
        super().__init__(master, columns=columns or (), show='headings', **kwargs)
        for col in (columns or ("col1", "col2")):
            self.heading(col, text=col)
            self.column(col, width=120, anchor='w')

class NumericUpDown(tk.Spinbox):
    def __init__(self, master=None, from_=0, to=100, increment=1, **kwargs):
        super().__init__(master, from_=from_, to=to, increment=increment, **kwargs)

class DatePicker(ttk.Entry):
    def __init__(self, master=None, **kwargs):
        super().__init__(master, **kwargs)
        # Simple placeholder date picker; user can type date

class Placeholder(ttk.Labelframe):
    def __init__(self, master=None, title='Placeholder', **kwargs):
        super().__init__(master, text=title, **kwargs)
        ttk.Label(self, text='Auto-generated placeholder').pack(anchor='w', padx=6, pady=4)

class MenuBar:
    def __init__(self, master, spec=None):
        self.menu = tk.Menu(master)
        # Basic File->Exit placeholder if no spec
        filem = tk.Menu(self.menu, tearoff=0)
        filem.add_command(label='Exit', command=master.destroy)
        self.menu.add_cascade(label='File', menu=filem)

class StatusBar(ttk.Frame):
    def __init__(self, master=None, text='', **kwargs):
        super().__init__(master, **kwargs)
        self._var = tk.StringVar(value=text)
        lbl = ttk.Label(self, textvariable=self._var, anchor='w')
        lbl.pack(fill='x')

class ToolBar(ttk.Frame):
    def __init__(self, master=None, **kwargs):
        super().__init__(master, **kwargs)
        # Placeholder toolbar with a button
        ttk.Button(self, text='Action').pack(side='left')

class CircleButton(tk.Canvas):
    def __init__(self, master=None, color='#FF5F56', size=12, command=None, **kwargs):
        super().__init__(master, width=size, height=size, highlightthickness=0, bg=kwargs.get('bg', self.master.cget('bg')))
        self._command = command
        r = size // 2
        self._oval = self.create_oval(1, 1, size-1, size-1, fill=color, outline=color)
        self.bind('<Button-1>', lambda e: self._command() if self._command else None)

class RoundedContextMenu:
    def __init__(self, master=None):
        self._menu = tk.Menu(master, tearoff=0)
    def AddItem(self, label, command=None):
        self._menu.add_command(label=label, command=command)
    def AddSeparator(self):
        self._menu.add_separator()
    def Show(self, widget, x, y=None):
        # widget: tk widget; x,y in widget coords; if only x is tuple, treat as event
        if isinstance(x, tuple) and y is None:
            x, y = x
        self._menu.tk_popup(widget.winfo_rootx()+x, widget.winfo_rooty()+y)
"""
